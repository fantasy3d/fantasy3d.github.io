<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<title>Fantasy 3D Mesh Refraction Material</title>
		<style>
			html {
				height: 100%;
			}
	
			body
			{
				font-family: Monospace;
				font-weight: bold;
				margin: 0px;
				height: 100%;
				overflow: hidden;
			}

            #gui_container{
				position: absolute;
				top: 1%;
				left: 45%;
			}

			#gui{
				transform:translate(-50%, -60px);
			}
		</style>
	</head>
	<body>
        <div id="gui_container"></div>
		<div id="viewport" style="width:100%; height:100%"></div>
		<script src='./js/libs/stats.min.js'></script>
        <script src="./js/loadscripts.js"></script>
        <script>loadscripts( { 
            
            "@fantasy3d/core": "../dist/fantasy.core.js",
            "@fantasy3d/addons": "../dist/fantasy.addons.js"
            
        } )</script>
        <script type="module">

            import { Pane } from './js/libs/tweakpane-4.0.3.min.js';
            import { CanvasTexture, Color, Mesh, MeshBasicMaterial, PlaneGeometry, RepeatWrapping, ShaderMaterial, Vector2, Vector3 } from 'three';
            import { Engine, Entity, EventType, ModelRenderer, GLTFParser, Scene, SceneRenderer } from '@fantasy3d/core';
            import { MeshRefractionMaterial, OrbitController } from '@fantasy3d/addons';

            // Create ui
            const pane = new Pane( { container: document.getElementById( 'gui_container' ), title: 'options', expanded: false } );

            // Create stats
            const stats = new Stats();
            document.body.appendChild( stats.dom );

            // Create engine
            const engine = new Engine( {

                // WebGL options
                gl: {

                    viewport: document.getElementById( 'viewport' ),
                    clearColor: '#f0f0f0'

                }

            } );

            // Update stats
            engine.on( EventType.BEFORE_FRAME_LOOP, () => {

                stats.update();

            } );
            
            // Create scene
            const scene = new Scene( engine );

            // Set scene renderer
            scene.sceneRenderer = new SceneRenderer( engine );

            // Create a perspective camera
            const camera = scene.createPerspectiveCamera( {

                transform: { 
                    
                    position: new Vector3( 0.0, 20.0, 10.0 ),
                    lookAt: new Vector3( 0.0, 0.0, 0.0 )

                },
                camera: { near: 0.1, far: 1000.0 }

            } );

            // Add orbitcontroller
            camera.addComponent( OrbitController, { damping: true } );
            
            // Active scene
            scene.isActive = true;

            // Load Diamond
            const { rootEntity } = scene;
            engine.resourceManager.loadGLTF( './assets/models/diamond.glb' ).then( ( resource ) => {

                // Parse glb
                const entity = GLTFParser.parse( resource );

                // Load Env map
                engine.resourceManager.loadHDRTexture( './assets/textures/hdr/equirectangular/aerodynamics_workshop_1k.hdr' ).then( ( res ) => {

                    // Get entities contain ModelRenderer and replace material
                    const materials = [];

                    const entities = Entity.findByComponent( entity, ModelRenderer );
                    for ( let i = 0, il = entities.length; i < il; i++ ) {

                        const { meshes } = entities[ i ].getComponent( ModelRenderer );
                        for ( let j = 0, jl = meshes.length; j < jl; j++ ) {

                            const mesh = meshes[ j ];

                            const material = new MeshRefractionMaterial( engine, {

                                bounces: 3,
                                ior: 2.75,
                                fresnel: 1.0,
                                envMap: res.reference().texture,
                                color: '#ffffff',
                                geometry: mesh.geometry

                            } ); 

                            mesh.material = material;

                            materials.push( material );

                        }

                    }

                    // Set ui
                    pane.addBinding( { bounces: 3 }, 'bounces', {

                        min: 0,
                        max: 8,
                        step: 1

                    } ).on( 'change', ( event ) => {

                        const { value } = event;

                        for ( let i = 0; i < materials.length; i++ ) {

                            materials[ i ].bounces = value;

                        }

                    } );

                    pane.addBinding( { ior: 2.75 }, 'ior', {

                        min: 0.0,
                        max: 10.0,
                        step: 0.05

                    } ).on( 'change', ( event ) => {

                        const { value } = event;

                        for ( let i = 0; i < materials.length; i++ ) {

                            materials[ i ].ior = value;

                        }

                    } );

                    pane.addBinding( { fresnel: 1.0 }, 'fresnel', {

                        min: 0.0,
                        max: 1.0,
                        step: 0.1

                    } ).on( 'change', ( event ) => {

                        const { value } = event;

                        for ( let i = 0; i < materials.length; i++ ) {

                            materials[ i ].fresnel = value;

                        }

                    } );
                    
                    pane.addBinding( { aberrationStrength: 0.01 }, 'aberrationStrength', {

                        min: 0.0,
                        max: 0.1,
                        step: 0.01

                    } ).on( 'change', ( event ) => {

                        const { value } = event;

                        for ( let i = 0; i < materials.length; i++ ) {

                            materials[ i ].aberrationStrength = value;

                        }

                    } );
                    
                    pane.addBinding( { color: '#ffffff' }, 'color', {

                        picker: 'inline',
                        expanded: false

                    } ).on( 'change', ( event ) => {

                        const { value } = event;

                        for ( let i = 0; i < materials.length; i++ ) {

                            materials[ i ].color = value;

                        }

                    } );

                } );

                // Add to scene
                rootEntity.addChild( entity );

            } );

        </script>
    </body>
</html>
